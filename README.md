# GraphJava
This project is about implementing a graph data structure with the use of a min heap, linked stack, priority queue, hashed dictionary, and vertices and edges. It utilizes methods with all the data structures and classes that allow for manipulation and retrieval of the data inside .

Section 1: Project Specification
	The abstract data type, or ADT, that was mainly used in this project was a graph. The graph was used to measure the distance between two airports and get the cheapest path from a certain airport to another. To elaborate, a graph ADT is a collection of distinct vertices and distinct edges. The graph was made to be a directed graph that utilizes directed edges, or paths, to connect vertices within the graph. Since the edges have an assigned weight, or distance, to them, they are referred to as weighted, directed edges. I incorporated this by having the distance be the weighted edges in the graph, and the vertices representing the airports. Moreover, to get the distance between two vertices, I had to find the cheapest path to take that would traverse through the weighted edges, all while keeping track of the distance accumulated until it got to its destination. For clarification, a “path” is a sequence of edges between two vertices in a graph. However, since the graph ADT uses directed edges, the paths are called “directed paths.” To keep track of the distance traveled, I would get a variable called “pathCost'' that would keep track of the length of the path, which is the total weight traveled through all the edges. In addition to the graph ADT’s specifications, there was Dijkstra’s algorithm, or the getCheapestPath method. What this method did was it would call upon iterators to iterate through the graph, going from vertex to vertex all while accounting for all the edge weights the iterators have traversed. At the end, the method would return a number which was the total distance, or weight, traveled through the graph. In addition, it would have a stack of airports that were traversed in the process, popping them out from the path stack to finally represent the path needed to get from the origin vertex to the destination vertex. Moving forward, the next ADT used was a priority queue that uses a minheap. A priority queue is essentially a queue ADT that orders the queue using something to keep track of priority within the objects within the queue. The queue ADT is a collection of objects that are organized in a first-in, first-out behavior where the first object added is the first one to be out of the queue. However, since it is a priority queue, the objects are not organized in the conventional manner, they are organized in highest priority to lowest priority. Additions to the priority queue would be inserted to their respective slots in the queue based on the priority value of themselves and those around them. Removals from the queue always occurred in the front, meaning whichever object has the highest priority would be removed from the front where it should have been located originally. Moving forward, since the priority queue implemented a minheap, it means the queue’s rules of priority were based on lowest value to highest value, where the lowest values are at the front of the queue. A minheap is a complete binary tree whose nodes contain Comparable objects. In addition, since it is a minheap that is used, objects in each node are less than or equal to the objects in the node’s descendants. The lowest values are at the top of the tree and the further you go down the tree, the more the values decrease. The minheap uses an array to represent the complete tree. I numbered the nodes in the order in which a level-order traversal would visit them. Moreover, because I used an array, based on their index number in the array, I could find the children or parent of any node. To find this, assume n is the index of the root node and simply do the computation of n/2 to find the parent, 2n for the left child, and 2n + 1 for the right child. For these computations to work, however, the first index must not be zero, but start at index one. Moving forward, when adding to the minheap, to find the correct spot for the new value added I may have needed to reheap, where I organize the tree to follow the same lowest to highest order. Therefore, a new entry would climb the tree starting at a leaf node, swapping values with each entry as it goes, eventually stopping when it finds the correct spot it belongs at in the tree. The minheap would reheap whenever entries were removed as well to maintain the complete binary tree. After implementing the minheap in the priority queue ADT, I would use the priority queue to accomplish finding the cheapest path between two vertices within the graph ADT for my project.
